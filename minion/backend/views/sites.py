#!/usr/bin/env python

import calendar
import datetime
import re
import uuid
from flask import jsonify, request
from celery.schedules import crontab_parser, ParseException

from minion.backend.app import app
import minion.backend.tasks as tasks
from minion.backend.views.base import api_guard
from minion.backend.views.groups import _check_group_exists
from minion.backend.models import db, Group, Site, ScanSchedule, SiteCredential, Plan

import json

def _check_site_url(url):
    regex = re.compile(r"^((http|https)://(localhost|([a-z0-9][-a-z0-9]*)(\.[a-z0-9][-a-z0-9]*)+)(:\d+)?)"
                       r"|"
                       r"((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/(\d|[1-2]\d|3[0-2]))?)$")
    return regex.match(url) is not None


#def _check_required_fields(expected, fields):
#    for field in fields:
#        if field not in expected:
#            return False
#    return True

def _find_groups_for_site(site):
    return Site.get_site(site).groups



def check_cron(crontab):
    cron_errors = []

    # Validate Minute
    try:
        crontab_parser(60).parse(crontab['minute'])
    except (ValueError, ParseException):
        cron_errors.append("Error in Value: Minute")

    # Validate Hour
    try:
        crontab_parser(24).parse(crontab['hour'])
    except (ValueError, ParseException):
        cron_errors.append("Error in Value: Hour")

    # Validate Day of Week
    try:
        crontab_parser(7).parse(crontab['day_of_week'])
    except (ValueError, ParseException):
        cron_errors.append("Error in Value: Day of Week")

    # Validate Day of Month
    try:
        crontab_parser(31,1).parse(crontab['day_of_month'])
    except (ValueError, ParseException):
        cron_errors.append("Error in Value: Day of Month")

    # Validate Month of Year
    try:
        crontab_parser(12,1).parse(crontab['month_of_year'])
    except (ValueError, ParseException):
        cron_errors.append("Error in Value: Month of Year")

    return cron_errors


# API Methods to manage sites

#
# Expects a site id to GET:
#
#  GET /sites/b263bdc6-8692-4ace-aa8b-922b9ec0fc37
#
# Returns the site record:
#
#  { 'success': True,
#    'site': { 'id': 'b263bdc6-8692-4ace-aa8b-922b9ec0fc37',
#              'url': 'https://www.mozilla.com',
#              'groups': ['mozilla', 'key-initiatives'] } }
#
# The groups list is not part of the site but is generated by querying the groups records.
#
# Or returns an error:
#
#  { 'success': False, 'reason': 'site-already-exists' }
#
#

@app.route('/sites/<site_id>', methods=['GET'])
@api_guard
def get_site(site_id):
    site = Site.get_site(site_id)
    if not site:
        return jsonify(success=False, reason='no-such-site')
    return jsonify(success=True, site=site.dict())

#
# Expects a partially filled out site as POST data:
#
#  POST /sites
#
#  { 'url': 'https://www.mozilla.com',
#    'plans': ['basic', 'nmap'],
#    'groups': ['mozilla', 'key-initiatives'] }
#
# Returns the full site record including the generated id:
#
#  { 'success': True,
#    'site': { 'id': 'b263bdc6-8692-4ace-aa8b-922b9ec0fc37',
#              'url': 'https://www.mozilla.com',
#              'plans': ['basic', 'nmap'],
#              'groups': ['mozilla', 'key-initiatives'] } }
#
# Or returns an error:
#
#  { 'success': False, 'reason': 'site-already-exists' }
#  { 'success': False, 'reason': 'Group xyz does not exist' }
#

@app.route('/sites', methods=['POST'])
@api_guard('application/json')
def create_site():
    site = request.json
    # Verify incoming site: url must be valid, groups must exist, plans must exist

    if not _check_site_url(site.get('url')):
        return jsonify(success=False, reason='invalid-url')
    if not site.get('url', None):
        return jsonify(success=False, reason='missing-required-field')
    for group in site.get('groups', []):
        if not Group.get_group(group):
            return jsonify(success=False, reason='unknown-group')
    for plan_name in site.get('plans', []):
        if not Plan.get_plan(plan_name):
            return jsonify(success=False, reason='unknown-plan')
    if Site.get_site_by_url(site['url']) is not None:
        return jsonify(success=False, reason='site-already-exists')




    # Create the site
    new_site = Site(site['url'])

    for plan in site.get('plans', []):
        new_site.plans.append(Plan.get_plan(plan))
    new_site.created = datetime.datetime.utcnow()

    for group in site.get('groups', []):
        new_site.groups.append(Group.get_group(group))

    if site.get('verification',{}).get('enabled',False):
        new_site.verification_enabled = True
        new_site.verification_value = str(uuid.uuid4())
    else:
        new_site.verification_enabled = False
        new_site.verification_value = None

    db.session.add(new_site)
    db.session.commit()
    new_site = Site.get_site(new_site.site_uuid)
    # Return the new site
    return jsonify(success=True, site=new_site.dict())

#
# Expects a partially filled out site as POST data. The site with the
# specified site_id (in the URL) will be updated.
#
# It is not possible to change the url. For that you need to delete the
# site and create a new one.
#
#  POST /sites/<site_id>
#
#  { 'url': 'https://www.mozilla.com',
#    'plans': ['basic', 'nmap'],
#    'groups': ['mozilla', 'key-initiatives'] }
#
# Returns the full site record including the generated id:
#
#  { 'success': True,
#    'site': { 'id': 'b263bdc6-8692-4ace-aa8b-922b9ec0fc37',
#              'url': 'https://www.mozilla.com',
#              'plans': ['basic', 'nmap'],
#              'groups': ['mozilla', 'key-initiatives'] } }
#
# Or returns an error:
#
#  { 'success': False, 'reason': 'no-such-site' }
#  { 'success': False, 'reason': 'unknown-group' }
#  { 'success': False, 'reason': 'unknown-plan' }
#

@app.route('/sites/<site_id>', methods=['POST'])
@api_guard
def update_site(site_id):
    new_site = request.json
    # Verify incoming site. It must exist, groups must exist, plans must exist.
    site = Site.get_site(site_id)

    if not site:
        return jsonify(success=False, reason='no-such-site')
    
    for group in new_site.get('groups', []):
        if not Group.get_group(group):
            return jsonify(success=False, reason='unknown-group')
    for plan_name in new_site.get('plans', []):
        if not Plan.get_plan(plan_name):
            return jsonify(success=False, reason='unknown-plan')

    

    if 'groups' in new_site:
        # purge groups
        for group in site.groups:
            site.groups.remove(group)

        # insert desired groups
        for group_name in new_site.get('groups', []):
            site.groups.append(Group.get_group(group_name))

    if 'plans' in new_site:
        #purge plans
        for plan in site.plans:
            site.plans.remove(plan)
        #add new plans
        for plan_name in new_site['plans']:
            site.plans.append(Plan.get_plan(plan_name))

    db.session.commit()
    # Return the updated site
    site = Site.get_site(site_id)
    if not site:
        return jsonify(success=False, reason='no-such-site')
    return jsonify(success=True, site=site.dict())

#
# Returns a list of sites or return the site matches the query. Currently
# only url is supported.
#
#  GET /sites
#  GET /sites?url=http://www.mozilla.com
#
# Returns a list of sites found, even if there is one result:
#
#  [{ 'id': 'b263bdc6-8692-4ace-aa8b-922b9ec0fc37',
#     'url': 'https://www.mozilla.com',
#     'groups': ['mozilla', 'key-initiatives'] },
#    ...]
#

@app.route('/sites', methods=['GET'])
@api_guard
def get_sites():
    query = {}
    url = request.args.get('url')
    sitez = None
    if url:
        sitez = [ Site.get_site_by_url(url)]
    else:
        sitez = Site.query.all()

    return jsonify(success=True, sites=map(lambda x : x.dict(), sitez))











#XXX help
# Returns credential Info exept for password from siteCredentials collection
@app.route('/credInfo', methods=['GET'])
@api_guard
def get_credInfo():
    credInfo = {}


    for site in SiteCredential.query.all():
        cred = site.dict()
        credInfo[cred['site']] = credInfo.get(cred['site'], {})
        credInfo[cred['site']][cred['plan']] = cred['authData']


    return jsonify(success=True, credInfo=credInfo)



#xxx help
# Sets siteCredentials
@app.route('/setCredentials', methods=["POST"])
@api_guard('application/json')
def setCredentials():
    cred_data = request.json
    site = Site.get_site_by_url(cred_data.get('site'))
    if not site:
        return jsonify(message="no-such-site", success=False)
    plan = Plan.get_plan(cred_data.get('plan'))
    if not plan:
        return jsonify(message="no-such-site", success=False)

    authData = cred_data.get('authData')


    siteCreds = SiteCredential.get_credential(site.id, plan.id)

    if not siteCreds:
        siteCreds = SiteCredential(site.id, plan.id)
        db.session.add(siteCreds)

    #update all fields, preserving values for which none was provided
    siteCreds.site_id = site.id
    siteCreds.plan_id = plan.id
    siteCreds.username = authData.get('username', siteCreds.username)
    siteCreds.emailaddress = authData.get('email', siteCreds.emailaddress)
    siteCreds.script = authData.get('script', siteCreds.script)
    siteCreds.url = authData.get('url', siteCreds.url)
    siteCreds.username_path = authData.get('meusername_field_xpathhod', siteCreds.username_path)
    siteCreds.password_path = authData.get('password_field_xpath', siteCreds.password_path)
    siteCreds.method = authData.get('method', siteCreds.method)
    siteCreds.cookies = authData.get('expected_cookies', siteCreds.cookies)
    siteCreds.before_login_path = authData.get('before_login_element_xpath', siteCreds.before_login_path)
    siteCreds.after_login_path = authData.get('after_login_element_xpath', siteCreds.after_login_path)
    siteCreds.button_path = authData.get('before_login_element_xpath', siteCreds.button_path)


    db.session.commit()
    return jsonify(credential = siteCreds.dict(), success=True)




@app.route('/scanschedule', methods=["POST"])
def scanschedule():
    site = request.json


    scan_id = site.get('scan_id')
    schedule = site.get('schedule')

    plan = site.get('plan')
    target = site.get('target')

    removeSite = schedule.get('remove')
    enabled = True
    crontab = {}
    message = "Scan Schedule not set"

    if removeSite is not None:
        # Removing scan from scanschedule results in incomplete removal because of celerybeat-mongo running in background
        # Hence  we just set "enabled" to false
        enabled = False
        message = "Removed Schedule for: " + target

    else:
        enabled = True
        message="Scheduled Scan successfully set for site: " + target



    crontab = {
      'minute':str(schedule.get('minute')),
      'hour':str(schedule.get('hour')),
      'day_of_week':str(schedule.get('dayOfWeek')),
      'day_of_month':str(schedule.get('dayOfMonth')),
      'month_of_year':str(schedule.get('monthOfYear'))
    }

    # Validate Crontab schedule values
    crontab_errors = check_cron(crontab)
    if crontab_errors:
        message = "Error in crontab values"
        return jsonify(message=message,success=False,errors=crontab_errors)

    data = {
      'task': "minion.backend.tasks.run_scheduled_scan",
      'args': [target, plan],
      'site': target,
      'queue':'scanschedule',
      'routing_key':'scanschedule',
      'exchange':'', #Exchange is not required. Fails sometimes if exchange is provided. #TODO Figure out why
      'plan': plan,
      'name': target + ":" + plan,
      'enabled': enabled,
      'crontab': crontab
    }

    # Insert/Update existing schedule by target and plan
    schedule = ScanSchedule.get_schedule(site, plan)

    schedule = scanschedules.find_one({"site":target, "plan":plan})
    if not schedule:
      schedule = ScanSchedule()
      schedule.data = json.dumps(data)
    else:
      old_data = json.loads(schedule.data)
      schedule.data = json.dumps(old_data.update(data))
      scanschedules.update({"site":target, "plan":plan},
                       {"$set": {"crontab": crontab, "enabled":enabled}});


    return jsonify(message=message,success=True)
